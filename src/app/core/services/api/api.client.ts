//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({ providedIn: 'root' })
export class Client {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:7113';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(
    version: string,
    body: RegisterRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/register';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  login(
    version: string,
    body: LoginRequest | undefined
  ): Observable<IdentityResponse> {
    let url_ = this.baseUrl + '/api/{version}/auth/login';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<IdentityResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<IdentityResponse>;
        })
      );
  }

  protected processLogin(
    response: HttpResponseBase
  ): Observable<IdentityResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as IdentityResponse);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  refresh(
    version: string,
    body: RefreshRequest | undefined
  ): Observable<IdentityResponse> {
    let url_ = this.baseUrl + '/api/{version}/auth/refresh';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefresh(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefresh(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<IdentityResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<IdentityResponse>;
        })
      );
  }

  protected processRefresh(
    response: HttpResponseBase
  ): Observable<IdentityResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as IdentityResponse);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  logout(version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/logout';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogout(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogout(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processLogout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  confirmEmail(
    version: string,
    body: ConfirmEmailRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/confirm/email';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processConfirmEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateUser(
    version: string,
    body: UpdateUserRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/user/update';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdateUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeEmail(
    version: string,
    body: ChangeEmailRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/change/email';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  confirmEmailChanging(
    version: string,
    body: ConfirmEmailChangingRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/change/email/confirm';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmEmailChanging(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmEmailChanging(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processConfirmEmailChanging(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(
    version: string,
    body: ChangePasswordRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/change/password';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangePassword(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param email (optional)
   * @return Success
   */
  resetPasswordRequest(
    email: string | undefined,
    version: string
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/reset/password/request?';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    if (email === null)
      throw new Error("The parameter 'email' cannot be null.");
    else if (email !== undefined)
      url_ += 'email=' + encodeURIComponent('' + email) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPasswordRequest(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPasswordRequest(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResetPasswordRequest(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(
    version: string,
    body: ResetPasswordRequest | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/auth/reset/password';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll(version: string): Observable<CategoryDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/categories';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              CategoryDTO[]
            >;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<CategoryDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as CategoryDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    version: string,
    body: CreateCategoryDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/categories';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update(
    version: string,
    body: UpdateCategoryDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/categories';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/categories/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get(id: number, version: string): Observable<CategoryDTO> {
    let url_ = this.baseUrl + '/api/{version}/categories/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<CategoryDTO>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CategoryDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as CategoryDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/categories/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getMainCategories(version: string): Observable<CategoryDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/categories/main';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMainCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMainCategories(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              CategoryDTO[]
            >;
        })
      );
  }

  protected processGetMainCategories(
    response: HttpResponseBase
  ): Observable<CategoryDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as CategoryDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll2(version: string): Observable<ContactRequestDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/contact-requests';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ContactRequestDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ContactRequestDTO[]
            >;
        })
      );
  }

  protected processGetAll2(
    response: HttpResponseBase
  ): Observable<ContactRequestDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ContactRequestDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create2(
    version: string,
    body: CreateContactRequestDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/contact-requests';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate2(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update2(
    version: string,
    body: UpdateContactRequestDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/contact-requests';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate2(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist2(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/contact-requests/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist2(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get2(id: number, version: string): Observable<ContactRequestDTO> {
    let url_ = this.baseUrl + '/api/{version}/contact-requests/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet2(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ContactRequestDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ContactRequestDTO>;
        })
      );
  }

  protected processGet2(
    response: HttpResponseBase
  ): Observable<ContactRequestDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ContactRequestDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete2(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/contact-requests/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete2(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll3(version: string): Observable<CouponDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/coupons';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll3(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CouponDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              CouponDTO[]
            >;
        })
      );
  }

  protected processGetAll3(
    response: HttpResponseBase
  ): Observable<CouponDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as CouponDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create3(
    version: string,
    body: CreateCouponDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/coupons';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate3(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate3(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update3(
    version: string,
    body: UpdateCouponDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/coupons';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate3(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate3(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist3(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/coupons/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist3(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist3(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get3(id: number, version: string): Observable<CouponDTO> {
    let url_ = this.baseUrl + '/api/{version}/coupons/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet3(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CouponDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<CouponDTO>;
        })
      );
  }

  protected processGet3(response: HttpResponseBase): Observable<CouponDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as CouponDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete3(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/coupons/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete3(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete3(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll4(version: string): Observable<EventDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/events';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll4(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<EventDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<EventDTO[]>;
        })
      );
  }

  protected processGetAll4(response: HttpResponseBase): Observable<EventDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as EventDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create4(
    version: string,
    body: CreateEventDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/events';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate4(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate4(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update4(version: string, body: UpdateEventDTO | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/events';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate4(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate4(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist4(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/events/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist4(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist4(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get4(id: number, version: string): Observable<EventDTO> {
    let url_ = this.baseUrl + '/api/{version}/events/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet4(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<EventDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<EventDTO>;
        })
      );
  }

  protected processGet4(response: HttpResponseBase): Observable<EventDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as EventDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Not Found',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete4(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/events/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete4(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete4(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll5(version: string): Observable<FiltersGroupDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll5(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll5(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                FiltersGroupDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              FiltersGroupDTO[]
            >;
        })
      );
  }

  protected processGetAll5(
    response: HttpResponseBase
  ): Observable<FiltersGroupDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as FiltersGroupDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create5(
    version: string,
    body: CreateFiltersGroupDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate5(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate5(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate5(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update5(
    version: string,
    body: UpdateFiltersGroupDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate5(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate5(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate5(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist5(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist5(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist5(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist5(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get5(id: number, version: string): Observable<FiltersGroupDTO> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet5(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet5(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FiltersGroupDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FiltersGroupDTO>;
        })
      );
  }

  protected processGet5(
    response: HttpResponseBase
  ): Observable<FiltersGroupDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as FiltersGroupDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Not Found',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete5(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete5(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete5(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete5(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getCategoryFiltersGroup(
    categoryId: number,
    version: string
  ): Observable<FiltersGroupDTO> {
    let url_ =
      this.baseUrl + '/api/{version}/filter-groups/category/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryFiltersGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryFiltersGroup(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FiltersGroupDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FiltersGroupDTO>;
        })
      );
  }

  protected processGetCategoryFiltersGroup(
    response: HttpResponseBase
  ): Observable<FiltersGroupDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as FiltersGroupDTO);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getCategoryFiltersGroup2(
    version: string,
    body: FiltersGroupOptionsDTO | undefined
  ): Observable<FiltersGroupDTO> {
    let url_ = this.baseUrl + '/api/{version}/filter-groups/category';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryFiltersGroup2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryFiltersGroup2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FiltersGroupDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FiltersGroupDTO>;
        })
      );
  }

  protected processGetCategoryFiltersGroup2(
    response: HttpResponseBase
  ): Observable<FiltersGroupDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as FiltersGroupDTO);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll6(version: string): Observable<MenuItemDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/menu-items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll6(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll6(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MenuItemDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              MenuItemDTO[]
            >;
        })
      );
  }

  protected processGetAll6(
    response: HttpResponseBase
  ): Observable<MenuItemDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as MenuItemDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create6(
    version: string,
    body: CreateMenuItemDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/menu-items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate6(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate6(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate6(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update6(
    version: string,
    body: UpdateMenuItemDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/menu-items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate6(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate6(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate6(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist6(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/menu-items/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist6(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist6(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist6(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get6(id: number, version: string): Observable<MenuItemDTO> {
    let url_ = this.baseUrl + '/api/{version}/menu-items/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet6(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet6(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MenuItemDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<MenuItemDTO>;
        })
      );
  }

  protected processGet6(response: HttpResponseBase): Observable<MenuItemDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as MenuItemDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Not Found',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete6(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/menu-items/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete6(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete6(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete6(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll7(version: string): Observable<NestedMenuItemDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/nested-menu-items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll7(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll7(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                NestedMenuItemDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              NestedMenuItemDTO[]
            >;
        })
      );
  }

  protected processGetAll7(
    response: HttpResponseBase
  ): Observable<NestedMenuItemDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as NestedMenuItemDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create7(
    version: string,
    body: CreateNestedMenuItemDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/nested-menu-items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate7(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate7(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate7(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update7(
    version: string,
    body: UpdateNestedMenuItemDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/nested-menu-items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate7(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate7(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate7(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist7(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/nested-menu-items/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist7(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist7(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist7(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get7(id: number, version: string): Observable<NestedMenuItemDTO> {
    let url_ = this.baseUrl + '/api/{version}/nested-menu-items/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet7(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet7(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<NestedMenuItemDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<NestedMenuItemDTO>;
        })
      );
  }

  protected processGet7(
    response: HttpResponseBase
  ): Observable<NestedMenuItemDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as NestedMenuItemDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Not Found',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete7(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/nested-menu-items/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete7(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete7(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete7(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll8(version: string): Observable<OrderDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/orders';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll8(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll8(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO[]>;
        })
      );
  }

  protected processGetAll8(response: HttpResponseBase): Observable<OrderDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as OrderDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create8(
    version: string,
    body: CreateOrderDTO | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/{version}/orders';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate8(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate8(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processCreate8(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as string);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update8(version: string, body: UpdateOrderDTO | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/orders';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate8(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate8(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate8(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist8(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/orders/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist8(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist8(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist8(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get8(id: number, version: string): Observable<OrderDTO> {
    let url_ = this.baseUrl + '/api/{version}/orders/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet8(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet8(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO>;
        })
      );
  }

  protected processGet8(response: HttpResponseBase): Observable<OrderDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete8(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/orders/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete8(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete8(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete8(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get9(number: string, version: string): Observable<OrderDTO> {
    let url_ = this.baseUrl + '/api/{version}/orders/{number}';
    if (number === undefined || number === null)
      throw new Error("The parameter 'number' must be defined.");
    url_ = url_.replace('{number}', encodeURIComponent('' + number));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet9(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet9(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO>;
        })
      );
  }

  protected processGet9(response: HttpResponseBase): Observable<OrderDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserOrders(userId: string, version: string): Observable<OrderDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/orders/user/{userId}';
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO[]>;
        })
      );
  }

  protected processGetUserOrders(
    response: HttpResponseBase
  ): Observable<OrderDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as OrderDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserOrders2(version: string): Observable<OrderDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/orders/user/current';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserOrders2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserOrders2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO[]>;
        })
      );
  }

  protected processGetUserOrders2(
    response: HttpResponseBase
  ): Observable<OrderDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as OrderDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserOrder(id: number, version: string): Observable<OrderDTO> {
    let url_ = this.baseUrl + '/api/{version}/orders/user/current/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserOrder(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO>;
        })
      );
  }

  protected processGetUserOrder(
    response: HttpResponseBase
  ): Observable<OrderDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as OrderDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserOrdersAwaitingReview(version: string): Observable<OrderDTO[]> {
    let url_ =
      this.baseUrl + '/api/{version}/orders/user/current/awaiting-reviews';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserOrdersAwaitingReview(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserOrdersAwaitingReview(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OrderDTO[]>;
        })
      );
  }

  protected processGetUserOrdersAwaitingReview(
    response: HttpResponseBase
  ): Observable<OrderDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as OrderDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  stripePayment(
    version: string,
    body: StripePaymentRequest | undefined
  ): Observable<PaymentSessionResponse> {
    let url_ = this.baseUrl + '/api/{version}/orders/payment/stripe';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStripePayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStripePayment(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaymentSessionResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaymentSessionResponse>;
        })
      );
  }

  protected processStripePayment(
    response: HttpResponseBase
  ): Observable<PaymentSessionResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as PaymentSessionResponse);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param orderNumber (optional)
   * @return Success
   */
  confirmStripePayment(
    orderNumber: string | undefined,
    version: string
  ): Observable<PaymentStatusResponse> {
    let url_ = this.baseUrl + '/api/{version}/orders/payment/stripe/confirm?';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    if (orderNumber === null)
      throw new Error("The parameter 'orderNumber' cannot be null.");
    else if (orderNumber !== undefined)
      url_ += 'orderNumber=' + encodeURIComponent('' + orderNumber) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmStripePayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmStripePayment(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaymentStatusResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaymentStatusResponse>;
        })
      );
  }

  protected processConfirmStripePayment(
    response: HttpResponseBase
  ): Observable<PaymentStatusResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as PaymentStatusResponse);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll9(version: string): Observable<ProductDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/products';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll9(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll9(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ProductDTO[]
            >;
        })
      );
  }

  protected processGetAll9(
    response: HttpResponseBase
  ): Observable<ProductDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProductDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create9(
    version: string,
    body: CreateProductDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/products';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate9(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate9(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate9(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update9(
    version: string,
    body: UpdateProductDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/products';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate9(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate9(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate9(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist9(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/products/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist9(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist9(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist9(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get10(id: number, version: string): Observable<ProductDTO> {
    let url_ = this.baseUrl + '/api/{version}/products/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet10(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet10(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProductDTO>;
        })
      );
  }

  protected processGet10(response: HttpResponseBase): Observable<ProductDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProductDTO);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete9(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/products/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete9(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete9(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete9(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getFilteredProducts(
    version: string,
    body: ProductsFilteringOptionsDTO | undefined
  ): Observable<ProductsPageDTO> {
    let url_ = this.baseUrl + '/api/{version}/products/page';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFilteredProducts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFilteredProducts(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductsPageDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ProductsPageDTO>;
        })
      );
  }

  protected processGetFilteredProducts(
    response: HttpResponseBase
  ): Observable<ProductsPageDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProductsPageDTO);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll10(version: string): Observable<ReviewDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/reviews';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll10(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll10(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReviewDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ReviewDTO[]
            >;
        })
      );
  }

  protected processGetAll10(
    response: HttpResponseBase
  ): Observable<ReviewDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ReviewDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create10(
    version: string,
    body: CreateReviewDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/reviews';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate10(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate10(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate10(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update10(
    version: string,
    body: UpdateReviewDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/reviews';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate10(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate10(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate10(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist10(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/reviews/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist10(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist10(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist10(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get11(id: number, version: string): Observable<ReviewDTO> {
    let url_ = this.baseUrl + '/api/{version}/reviews/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet11(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet11(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReviewDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ReviewDTO>;
        })
      );
  }

  protected processGet11(response: HttpResponseBase): Observable<ReviewDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as ReviewDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete10(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/reviews/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete10(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete10(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete10(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getReviewsByProduct(
    productId: number,
    version: string
  ): Observable<ReviewDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/reviews/product/{productId}';
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReviewsByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReviewsByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReviewDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ReviewDTO[]
            >;
        })
      );
  }

  protected processGetReviewsByProduct(
    response: HttpResponseBase
  ): Observable<ReviewDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ReviewDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserReviews(userId: string, version: string): Observable<ReviewDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/reviews/user/{userId}';
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserReviews(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserReviews(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReviewDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ReviewDTO[]
            >;
        })
      );
  }

  protected processGetUserReviews(
    response: HttpResponseBase
  ): Observable<ReviewDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ReviewDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserReviews2(version: string): Observable<ReviewDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/reviews/user/current';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserReviews2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserReviews2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReviewDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ReviewDTO[]
            >;
        })
      );
  }

  protected processGetUserReviews2(
    response: HttpResponseBase
  ): Observable<ReviewDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ReviewDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserReview(id: number, version: string): Observable<ReviewDTO> {
    let url_ = this.baseUrl + '/api/{version}/reviews/user/current/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserReview(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserReview(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReviewDTO>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ReviewDTO>;
        })
      );
  }

  protected processGetUserReview(
    response: HttpResponseBase
  ): Observable<ReviewDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as ReviewDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll11(version: string): Observable<SpecificationDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/specifications';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll11(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll11(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SpecificationDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SpecificationDTO[]
            >;
        })
      );
  }

  protected processGetAll11(
    response: HttpResponseBase
  ): Observable<SpecificationDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SpecificationDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create11(
    version: string,
    body: CreateSpecificationDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/specifications';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate11(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate11(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate11(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update11(
    version: string,
    body: UpdateSpecificationDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/specifications';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate11(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate11(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate11(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist11(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/specifications/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist11(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist11(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist11(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get12(id: number, version: string): Observable<SpecificationDTO> {
    let url_ = this.baseUrl + '/api/{version}/specifications/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet12(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet12(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SpecificationDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SpecificationDTO>;
        })
      );
  }

  protected processGet12(
    response: HttpResponseBase
  ): Observable<SpecificationDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SpecificationDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete11(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/specifications/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete11(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete11(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete11(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  getMany(
    ids: number[] | undefined,
    version: string
  ): Observable<SpecificationDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/specifications/many?';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    if (ids === null) throw new Error("The parameter 'ids' cannot be null.");
    else if (ids !== undefined)
      ids &&
        ids.forEach((item) => {
          url_ += 'ids=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMany(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMany(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SpecificationDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SpecificationDTO[]
            >;
        })
      );
  }

  protected processGetMany(
    response: HttpResponseBase
  ): Observable<SpecificationDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SpecificationDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll12(version: string): Observable<SpecificationTypeDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/specification-types';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll12(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll12(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SpecificationTypeDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SpecificationTypeDTO[]
            >;
        })
      );
  }

  protected processGetAll12(
    response: HttpResponseBase
  ): Observable<SpecificationTypeDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SpecificationTypeDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create12(
    version: string,
    body: CreateSpecificationTypeDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/specification-types';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate12(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate12(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate12(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update12(
    version: string,
    body: UpdateSpecificationTypeDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/specification-types';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate12(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate12(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate12(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist12(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/specification-types/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist12(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist12(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist12(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get13(id: number, version: string): Observable<SpecificationTypeDTO> {
    let url_ = this.baseUrl + '/api/{version}/specification-types/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet13(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet13(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<SpecificationTypeDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SpecificationTypeDTO>;
        })
      );
  }

  protected processGet13(
    response: HttpResponseBase
  ): Observable<SpecificationTypeDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SpecificationTypeDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          result404 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Not Found',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete12(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/specification-types/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete12(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete12(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete12(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  get14(
    version: string,
    body: SpecificationTypeOptionsDTO | undefined
  ): Observable<SpecificationTypeDTO> {
    let url_ = this.baseUrl + '/api/{version}/specification-types/by-options';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet14(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet14(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<SpecificationTypeDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SpecificationTypeDTO>;
        })
      );
  }

  protected processGet14(
    response: HttpResponseBase
  ): Observable<SpecificationTypeDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SpecificationTypeDTO);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll13(version: string): Observable<SubscriberDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/subscribers';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll13(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll13(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SubscriberDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SubscriberDTO[]
            >;
        })
      );
  }

  protected processGetAll13(
    response: HttpResponseBase
  ): Observable<SubscriberDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SubscriberDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create13(
    version: string,
    body: CreateSubscriberDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/subscribers';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate13(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate13(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate13(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update13(
    version: string,
    body: UpdateSubscriberDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/subscribers';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate13(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate13(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate13(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  exist13(id: number, version: string): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/subscribers/exists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist13(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist13(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist13(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get15(id: number, version: string): Observable<SubscriberDTO> {
    let url_ = this.baseUrl + '/api/{version}/subscribers/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet15(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet15(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SubscriberDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SubscriberDTO>;
        })
      );
  }

  protected processGet15(
    response: HttpResponseBase
  ): Observable<SubscriberDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SubscriberDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete13(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/subscribers/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete13(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete13(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete13(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get16(email: string, version: string): Observable<SubscriberDTO> {
    let url_ = this.baseUrl + '/api/{version}/subscribers/{email}';
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace('{email}', encodeURIComponent('' + email));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet16(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet16(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SubscriberDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SubscriberDTO>;
        })
      );
  }

  protected processGet16(
    response: HttpResponseBase
  ): Observable<SubscriberDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as SubscriberDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAll14(version: string): Observable<WishlistDTO[]> {
    let url_ = this.baseUrl + '/api/{version}/wishlists';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll14(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll14(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishlistDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              WishlistDTO[]
            >;
        })
      );
  }

  protected processGetAll14(
    response: HttpResponseBase
  ): Observable<WishlistDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as WishlistDTO[]);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create14(
    version: string,
    body: CreateWishlistDTO | undefined
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/{version}/wishlists';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate14(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate14(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate14(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          result422 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Client Error',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  update14(
    version: string,
    body: UpdateWishlistDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/wishlists';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate14(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate14(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate14(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param productId (optional)
   * @return Success
   */
  exist14(
    productId: number | undefined,
    version: string,
    id: string
  ): Observable<boolean> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/exists/{id}?';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (productId === null)
      throw new Error("The parameter 'productId' cannot be null.");
    else if (productId !== undefined)
      url_ += 'productId=' + encodeURIComponent('' + productId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExist14(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExist14(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processExist14(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  get17(id: number, version: string): Observable<WishlistDTO> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet17(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet17(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishlistDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<WishlistDTO>;
        })
      );
  }

  protected processGet17(response: HttpResponseBase): Observable<WishlistDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as WishlistDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return No Content
   */
  delete14(id: number, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete14(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete14(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete14(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserWishlist(userId: string, version: string): Observable<WishlistDTO> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/user/{userId}';
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishlistDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<WishlistDTO>;
        })
      );
  }

  protected processGetUserWishlist(
    response: HttpResponseBase
  ): Observable<WishlistDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as WishlistDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          result403 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Forbidden',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getUserWishlist2(version: string): Observable<WishlistDTO> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/user/current';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserWishlist2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserWishlist2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WishlistDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<WishlistDTO>;
        })
      );
  }

  protected processGetUserWishlist2(
    response: HttpResponseBase
  ): Observable<WishlistDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as WishlistDTO);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  addItem(
    version: string,
    body: CreateWishlistItemDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddItem(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddItem(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAddItem(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  updateItem(
    version: string,
    body: UpdateWishlistItemDTO | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/items';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateItem(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateItem(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdateItem(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param itemId (optional)
   * @return No Content
   */
  removeItem(itemId: number | undefined, version: string): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/items?';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    if (itemId === null)
      throw new Error("The parameter 'itemId' cannot be null.");
    else if (itemId !== undefined)
      url_ += 'itemId=' + encodeURIComponent('' + itemId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveItem(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveItem(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRemoveItem(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return No Content
   */
  removeItems(version: string, body: number[] | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/{version}/wishlists/items/many';
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveItems(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRemoveItems(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  checkProductPresence(
    productId: number,
    version: string
  ): Observable<boolean> {
    let url_ =
      this.baseUrl +
      '/api/{version}/wishlists/items/exists/product-id/{productId}';
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckProductPresence(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckProductPresence(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processCheckProductPresence(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as boolean);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getItemId(productId: number, version: string): Observable<number> {
    let url_ =
      this.baseUrl + '/api/{version}/wishlists/items/product-id/{productId}';
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace('{version}', encodeURIComponent('' + version));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetItemId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetItemId(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processGetItemId(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : (JSON.parse(_responseText, this.jsonParseReviver) as number);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          result401 =
            _responseText === ''
              ? null
              : (JSON.parse(
                  _responseText,
                  this.jsonParseReviver
                ) as ProblemDetails);
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface CategoryDTO {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  rootId?: number | undefined;
  parentId?: number | undefined;
  childCategories?: CategoryDTO[] | undefined;
  isMainCategory?: boolean;
}

export interface ChangeEmailRequest {
  userId: string;
  newEmail: string;
}

export interface ChangePasswordRequest {
  userId: string;
  oldPassword: string;
  newPassword: string;
  newPasswordConfirmation: string;
}

export interface ConfirmEmailChangingRequest {
  userId: string;
  token: string;
  newEmail: string;
}

export interface ConfirmEmailRequest {
  userId: string;
  token: string;
}

export interface ContactRequestDTO {
  id?: number;
  contactName?: string | undefined;
  email?: string | undefined;
  message?: string | undefined;
  creationDate?: Date;
  responseDate?: Date | undefined;
  isConsidered?: boolean;
}

export interface CouponDTO {
  id?: number;
  number?: string | undefined;
  creationDate?: Date;
  startDate?: Date;
  finishDate?: Date | undefined;
  discountSize?: number;
  percentDiscountSize?: number;
  maxUsesCount?: number;
  currentUsesCount?: number;
  isNotUsesLimit?: boolean;
  isActive?: boolean;
}

export interface CreateCategoryDTO {
  name?: string | undefined;
  description?: string | undefined;
  rootId?: number | undefined;
  parentId?: number | undefined;
  isMainCategory?: boolean;
}

export interface CreateContactRequestDTO {
  contactName?: string | undefined;
  email?: string | undefined;
  message?: string | undefined;
  isConsidered?: boolean;
}

export interface CreateCouponDTO {
  number?: string | undefined;
  startDate?: Date;
  finishDate?: Date | undefined;
  discountSize?: number;
  percentDiscountSize?: number;
  maxUsesCount?: number;
  isNotUsesLimit?: boolean;
  isActive?: boolean;
}

export interface CreateEventDTO {
  name?: string | undefined;
  startDate?: Date;
  finishDate?: Date;
  description?: string | undefined;
  image?: string | undefined;
}

export interface CreateFiltersGroupDTO {
  categoryId?: number;
  specificationTypeIds?: number[] | undefined;
}

export interface CreateMenuItemDTO {
  name?: string | undefined;
  categoryId?: number;
  isMegaMenu?: boolean;
  image?: string | undefined;
}

export interface CreateNestedMenuItemDTO {
  name?: string | undefined;
  parentId?: number;
  categoryIds?: number[] | undefined;
  hasTwoColumns?: boolean;
}

export interface CreateOrderDTO {
  items?: CreateOrderItemDTO[] | undefined;
  status?: OrderStatus;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
  shippingCost?: number;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  postcode?: string | undefined;
  streetAddress?: string | undefined;
  apartment?: string | undefined;
  notes?: string | undefined;
}

export interface CreateOrderItemDTO {
  productId?: number;
  quantity?: number;
}

export interface CreateProductDTO {
  name?: string | undefined;
  unitPrice?: number;
  discount?: number;
  unitsInStock?: number;
  description?: string | undefined;
  image?: string | undefined;
  categoryId?: number;
  specifications?: SpecificationDTO[] | undefined;
  manufacturer?: string | undefined;
  manufacturersCode?: string | undefined;
  storeCode?: string | undefined;
  isAvailable?: boolean;
  isNewProduct?: boolean;
  isSale?: boolean;
  isFeaturedProduct?: boolean;
}

export interface CreateReviewDTO {
  productId?: number;
  orderId?: number | undefined;
  name?: string | undefined;
  rating?: number;
  content?: string | undefined;
}

export interface CreateSpecificationDTO {
  specificationTypeId?: number;
  value?: string | undefined;
}

export interface CreateSpecificationTypeDTO {
  name?: string | undefined;
  displayName?: string | undefined;
  isMain?: boolean;
  values?: CreateSpecificationDTO[] | undefined;
}

export interface CreateSubscriberDTO {
  email?: string | undefined;
  isActive?: boolean;
}

export interface CreateWishlistDTO {
  items?: CreateWishlistItemDTO[] | undefined;
}

export interface CreateWishlistItemDTO {
  productId?: number;
  quantity?: number;
}

export interface EventDTO {
  id?: number;
  name?: string | undefined;
  startDate?: Date;
  finishDate?: Date;
  description?: string | undefined;
  image?: string | undefined;
}

export interface FiltersGroupDTO {
  id?: number;
  categoryId?: number;
  category?: CategoryDTO;
  specificationTypes?: SpecificationTypeDTO[] | undefined;
}

export interface FiltersGroupOptionsDTO {
  categoryId?: number;
  appliedFilters?: { [key: string]: number[] } | undefined;
}

export interface IdentityResponse {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
}

export interface LoginRequest {
  usernameOrEmail: string;
  password: string;
}

export interface MenuItemDTO {
  id?: number;
  name?: string | undefined;
  categoryId?: number;
  isMegaMenu?: boolean;
  nestedItems?: NestedMenuItemDTO[] | undefined;
  image?: string | undefined;
}

export interface NestedMenuItemDTO {
  id?: number;
  name?: string | undefined;
  parentId?: number;
  categories?: CategoryDTO[] | undefined;
  hasTwoColumns?: boolean;
}

export interface OrderDTO {
  id?: number;
  number?: string | undefined;
  items?: OrderItemDTO[] | undefined;
  status?: OrderStatus;
  creationDate?: Date;
  payDate?: Date | undefined;
  shippedDate?: Date | undefined;
  paymentMethod?: string | undefined;
  paymentSession?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
  total?: number;
  shippingCost?: number;
  trackingNumber?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  postcode?: string | undefined;
  streetAddress?: string | undefined;
  apartment?: string | undefined;
  notes?: string | undefined;
}

export interface OrderItemDTO {
  id?: number;
  orderId?: number;
  productId?: number;
  product?: ProductDTO;
  quantity?: number;
  unitPrice?: number;
  discount?: number;
}

export type OrderStatus = 0 | 1 | 2 | 3 | 4 | 5;

export interface PaymentSessionResponse {
  sessionUrl?: string | undefined;
}

export interface PaymentStatusResponse {
  orderNumber?: string | undefined;
  isPaid?: boolean;
  isFailed?: boolean;
  isInProcess?: boolean;
}

export interface ProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export interface ProductDTO {
  id?: number;
  name?: string | undefined;
  unitPrice?: number;
  discount?: number;
  unitsInStock?: number;
  description?: string | undefined;
  image?: string | undefined;
  categoryId?: number;
  category?: CategoryDTO;
  specifications?: SpecificationDTO[] | undefined;
  rating?: number;
  reviewsCount?: number;
  reviews?: ReviewDTO[] | undefined;
  manufacturer?: string | undefined;
  manufacturersCode?: string | undefined;
  storeCode?: string | undefined;
  isAvailable?: boolean;
  isNewProduct?: boolean;
  isSale?: boolean;
  isFeaturedProduct?: boolean;
}

export interface ProductsFilteringOptionsDTO {
  categoryId?: number;
  minPrice?: number;
  maxPrice?: number;
  specificationIds?: { [key: string]: number[] } | undefined;
  pageNumber?: number;
  itemsPerPage?: number;
  sortBy?: SortParameter;
}

export interface ProductsPageDTO {
  products?: ProductDTO[] | undefined;
  category?: CategoryDTO;
  currentPage?: number;
  totalPages?: number;
  itemsPerPage?: number;
}

export interface RefreshRequest {
  userId: string;
  refreshToken: string;
}

export interface RegisterRequest {
  firstName: string;
  lastName: string;
  username: string;
  email: string;
  password: string;
  passwordConfirmation: string;
}

export interface ResetPasswordRequest {
  userId: string;
  token: string;
  newPassword: string;
  newPasswordConfirmation: string;
}

export interface ReviewDTO {
  id?: number;
  productId?: number;
  product?: ProductDTO;
  orderId?: number | undefined;
  order?: OrderDTO;
  creationDate?: Date;
  lastChangeDate?: Date;
  name?: string | undefined;
  rating?: number;
  content?: string | undefined;
}

export type SortParameter = 0 | 1 | 2 | 3;

export interface SpecificationDTO {
  id?: number;
  specificationTypeId?: number;
  specificationType?: SpecificationTypeDTO;
  value?: string | undefined;
  products?: ProductDTO[] | undefined;
  productsCount?: number;
}

export interface SpecificationTypeDTO {
  id?: number;
  name?: string | undefined;
  displayName?: string | undefined;
  isMain?: boolean;
  values?: SpecificationDTO[] | undefined;
}

export interface SpecificationTypeOptionsDTO {
  id?: number;
  appliedFilters?: { [key: string]: number[] } | undefined;
}

export interface StripePaymentRequest {
  successUrl?: string | undefined;
  cancelUrl?: string | undefined;
  orderNumber?: string | undefined;
}

export interface SubscriberDTO {
  id?: number;
  email?: string | undefined;
  subscribeDate?: Date;
  isActive?: boolean;
}

export interface UpdateCategoryDTO {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  rootId?: number | undefined;
  parentId?: number | undefined;
  isMainCategory?: boolean;
}

export interface UpdateContactRequestDTO {
  id?: number;
  contactName?: string | undefined;
  email?: string | undefined;
  message?: string | undefined;
  responseDate?: Date | undefined;
  isConsidered?: boolean;
}

export interface UpdateCouponDTO {
  id?: number;
  number?: string | undefined;
  startDate?: Date;
  finishDate?: Date | undefined;
  discountSize?: number;
  percentDiscountSize?: number;
  maxUsesCount?: number;
  currentUsesCount?: number;
  isNotUsesLimit?: boolean;
  isActive?: boolean;
}

export interface UpdateEventDTO {
  id?: number;
  name?: string | undefined;
  startDate?: Date;
  finishDate?: Date;
  description?: string | undefined;
  image?: string | undefined;
}

export interface UpdateFiltersGroupDTO {
  id?: number;
  categoryId?: number;
  category?: CategoryDTO;
  specificationTypeIds?: number[] | undefined;
}

export interface UpdateMenuItemDTO {
  id?: number;
  name?: string | undefined;
  categoryId?: number;
  isMegaMenu?: boolean;
  image?: string | undefined;
}

export interface UpdateNestedMenuItemDTO {
  id?: number;
  name?: string | undefined;
  parentId?: number;
  categoryIds?: number[] | undefined;
  hasTwoColumns?: boolean;
}

export interface UpdateOrderDTO {
  id?: number;
  status?: OrderStatus;
  shippedDate?: Date | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
  total?: number;
  shippingCost?: number;
  trackingNumber?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  postcode?: string | undefined;
  streetAddress?: string | undefined;
  apartment?: string | undefined;
  notes?: string | undefined;
}

export interface UpdateProductDTO {
  id?: number;
  name?: string | undefined;
  unitPrice?: number;
  discount?: number;
  unitsInStock?: number;
  description?: string | undefined;
  image?: string | undefined;
  categoryId?: number;
  specifications?: SpecificationDTO[] | undefined;
  rating?: number;
  manufacturer?: string | undefined;
  manufacturersCode?: string | undefined;
  storeCode?: string | undefined;
  isAvailable?: boolean;
  isNewProduct?: boolean;
  isSale?: boolean;
  isFeaturedProduct?: boolean;
}

export interface UpdateReviewDTO {
  id?: number;
  name?: string | undefined;
  rating?: number;
  content?: string | undefined;
}

export interface UpdateSpecificationDTO {
  id?: number;
  specificationTypeId?: number;
  value?: string | undefined;
}

export interface UpdateSpecificationTypeDTO {
  id?: number;
  name?: string | undefined;
  displayName?: string | undefined;
  isMain?: boolean;
}

export interface UpdateSubscriberDTO {
  id?: number;
  email?: string | undefined;
  isActive?: boolean;
}

export interface UpdateUserRequest {
  userId: string;
  firstName: string;
  lastName: string;
  username: string;
  phoneNumber?: string | undefined;
  dateOfBirth?: Date | undefined;
}

export interface UpdateWishlistDTO {
  id?: number;
  lastChangeDate?: Date;
  items?: UpdateWishlistItemDTO[] | undefined;
}

export interface UpdateWishlistItemDTO {
  id?: number;
  productId?: number;
  quantity?: number;
}

export interface WishlistDTO {
  id?: number;
  creationDate?: Date;
  lastChangeDate?: Date;
  items?: WishlistItemDTO[] | undefined;
}

export interface WishlistItemDTO {
  id?: number;
  wishlistId?: number;
  productId?: number;
  product?: ProductDTO;
  quantity?: number;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
